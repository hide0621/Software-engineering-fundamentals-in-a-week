- 基本設計(外部設計)...発注者側の設計、アプリのUIや振る舞い、入力と出力などを決めること。コードを書かない人の為の設計。

- 詳細設計(内部設計)...開発者側の設計、どんな処理を書いて実装するとか、データのあり方はどうするかとか、どんな言語、どんなフレームワークなどの技術の選定、そこで使用するアーキテクチャ、DB設計などを決めること。

- UML...プロパティとメソッドで構成された図、書き方が決まっている 

- クラス図...クラス名、プロパティ、メソッドで構成される、クラス=エンティティ！？

- オブジェクト図...どのオブジェクトがどのオブジェクトを呼んでいるのか？、オブジェクト=レコードor値！？

- シーケンス図...どのオブジェクトがどのメソッド(振る舞い)でどのオブジェクトを呼んでいるのか？ 

- 基本設計の構成要素...どんな画面にどんな項目があるか、それはどんなデータ型で容量はどうか、全件表示なのか一部表示なのか、はたまたページングなのか、テーブルに保存するのかファイルなのか、そのメンテナンスはどうするのか、他のツールを使うのか、バッチ処理はどんな処理手順でいつ行うのか、そもそもサーバーはいくつ必要で、ロードバランサーはあるのか、APIはどんなものがいくつ必要か、モノリスなのかマイクロサービスなのかモジュールモノリスなのか、クリーンアーキテクチャなのか、アプリも同様にMVCなのかMVVMなのか、スケールするならどんなスケールでどのくらいスケールしていつ実施されるのか、クラウドなのかオンプレなのか、今後のマイグレーションの予定はどうか等。

- API...例えばあるシステム、アプリ、機能が別のそれらを利用したいとする。この時、それを提供してくれるものがあった時(例えばひらがなAPIやSentry等)、その呼出口のことをAPIと言う。そのAPIに対して指定のURLとメソッド、パラメータを与えた時に指定のレスポンスを返すようになっており、利用者側から見た時はそれがどのような内部処理をしているかは分からないが、機能要件を満たしているようになる。例えるならAPIとは、水を飲みたい時の蛇口のようなものである。

- 主キー...あるテーブルのレコードを一意に識別するためのカラム 

- 論理削除...あるテーブルのデータが既に削除済みであることを識別するためのフラグのこと。そのデータの削除を行うことが難しい時に採用される。 

- 抽象化...複数のコードで流用されている部分を切り出したり、インターフェース化やabstract化、ジェネリック化したりして似たようなコードの重複を削除したり、機能だけは提供して内部の処理は見せないようにすることで(モジュール化)、保守性を高める作業のこと。複雑なものから重要な部分を抽出したり、重要な部分だけを見せて、そうでない部分は隠すこと。共通の部分を見出して(パターンを見つけて)、概念化すること。
[この記事が分かり易い](https://qiita.com/t1k2a/items/42e9acde38df9d6246be)

- カプセル化...オブジェクト指向プログラミングのパラダイムで生まれた概念。手続き型言語にあった『どこからでも呼び出せるが故に呼ぶべきでないものを呼んでしまった』と言うような事象に対して、外部に公開されている部分しか呼び出せないようにすることで、外部から直接読んでほしくない部分を隠すことが出来る 

- 3層アーキテクチャ...プレゼンテーション層がリクエストを受け、それをアプリケーション層に流してユースケースの処理を実行し、それをデータアクセス層に流してDBに反映させ、そこから逆戻りさせる設計 

- MVC...ViewがUI(出力)、ユーザーからのアクセスを受けつけて(入力)、ユースケースごとに振り分けるハンドラーの役割のController、ユースケースを実行したり、その処理結果をDBに反映させる(処理する)Model、その結果がControllerに返ってきて、それがViewに反映される(出力)設計 

- 排他制御...ある処理(トランザクション)がDBに走っている間は他の処理は走れないようにすること 

- 楽観ロック...誰かの更新系の処理が走っている間でも自分の更新系の処理は出来るが、それをコミットする際は誰かの更新系の処理がコミットされていないことが条件になる 

- 悲観ロック...誰かの更新系の処理が走っている間は自分は更新系の処理は出来ない